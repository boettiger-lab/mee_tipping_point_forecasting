---
title: "scoring"
output: github_document
date: '2022-04-13'
---


```{r}
library(scoringRules)
library(tidyverse)
```


```{r}
data <- read_csv("forecasts/block_rnn_stochastic_10.csv.gz")[-1]
emp_draws <- data %>% filter(true_model==TRUE) %>% select(-true_model)
forecasts <- data %>% filter(true_model==FALSE) %>% select(-true_model)
```

```{r}
library(scoringRules)

scores <- function(observed, dat) {
  logsscore <- scoringRules::logs_sample(observed, dat)
  crpsscore <- scoringRules::crps_sample(observed, dat)
  data.frame(logs = mean(logsscore[-1]), crps =  mean(crpsscore[-1]))
}
```


```{r}

## Currently it looks like only one tp_model and one ml_model, but 5 iterations:
## We will need to generalize this code to map over multiple tp_models and ml_models etc
# forecasts %>% count(tp_model, ml_model, iter)

## pivot forecast into a matrix of size(time) x size(ensembles)
i <- 1
dat <- forecasts |> filter(iter == i) |>
  select(t = time, i = ensemble, N = value) |> 
 pivot_wider(id_cols = "t", names_from="i", values_from = "N") |> 
  select(-t) |> as.matrix()

test <- emp_draws |> filter(iter == i)  |>
  select(t = time, i = ensemble, N = value)
```

```{r}
bench::bench_time({
rep_scores <- 
  test |> 
  group_by(i) |> 
  group_map(~ scores(.x$N, dat)) |> 
  bind_rows()
})
```


```{r}
library(patchwork)
ggplot(all_scores) + geom_histogram(aes(crps)) + 
(ggplot(all_scores) + geom_histogram(aes(logs)) )

```